---
title: Architecture
---

import Image from "../../components/Image.astro";

## Overview

Player is built around a plugin-based architecture that provides extensibility at every level. The core system is designed to be platform-agnostic, with platform-specific implementations built on top of the shared foundation.

## Core Architecture

### Player Class

The core `Player` class serves as the foundation for all Player implementations. It provides:

- **Plugin Management** - Registration and lifecycle management
- **Hook System** - Tapable hooks for extending functionality
- **State Management** - Flow execution and state transitions
- **Controller System** - Modular controllers for different concerns

### Controllers

Player uses a controller-based architecture to separate concerns:

- **FlowController** - Manages flow execution and state machines
- **ViewController** - Handles view rendering and updates
- **DataController** - Manages data binding and state
- **ValidationController** - Handles schema validation
- **ExpressionController** - Evaluates expressions and bindings
- **ConstantsController** - Manages constants and context

### Hook System

The plugin system is built around Tapable hooks that allow plugins to:

- **Tap into lifecycle events** - View updates, state changes, flow transitions
- **Modify behavior** - Transform data, add validation, extend functionality
- **Register new capabilities** - Add new asset types, expressions, or validators

## Plugin System

### Plugin Types

```typescript
export interface PlayerPlugin {
  /** Unique identifier of the plugin */
  symbol?: symbol;

  /** The name of the plugin */
  name: string;

  /** Use this to tap into Player hooks */
  apply: (player: Player) => void;
}
```

### Core Hooks

```typescript
export interface PlayerHooks {
  flowController: SyncHook<[FlowController]>;
  viewController: SyncHook<[ViewController]>;
  view: SyncHook<[ViewInstance]>;
  expressionEvaluator: SyncHook<[ExpressionController]>;
  dataController: SyncHook<[DataController]>;
  validationController: SyncHook<[ValidationController]>;
  state: SyncHook<[PlayerFlowState]>;
  onStart: SyncHook<[Flow]>;
  onEnd: SyncHook<[]>;
  resolveFlowContent: SyncWaterfallHook<[Flow]>;
}
```

### Plugin Examples

**Basic Plugin:**

```typescript
class MyPlugin implements PlayerPlugin {
  name = "MyPlugin";

  apply(player: Player) {
    player.hooks.view.tap(this.name, (view) => {
      // Handle view updates
      console.log("View updated:", view);
    });
  }
}
```

**Data Transformation Plugin:**

```typescript
class DataTransformPlugin implements PlayerPlugin {
  name = "DataTransformPlugin";

  apply(player: Player) {
    player.hooks.dataController.tap(this.name, (dataController) => {
      // Transform data before it's used
      dataController.hooks.onUpdate.tap(this.name, (data) => {
        return transformData(data);
      });
    });
  }
}
```

## Platform Implementations

### React Player

The React Player extends the core Player with React-specific functionality:

- **Component Rendering** - Renders Player views as React components
- **Asset Registry** - Maps Player assets to React components
- **State Integration** - Integrates with React state management

### iOS Player

The iOS implementation provides:

- **SwiftUI Integration** - Native SwiftUI views
- **JavaScriptCore Runtime** - JavaScript execution environment
- **Plugin Architecture** - Native plugin system for iOS-specific functionality

### Android Player

The Android implementation includes:

- **View System Integration** - Native Android views
- **Multiple Runtime Support** - J2V8, Hermes, GraalJS
- **Lifecycle Management** - Integration with Android lifecycle components

## Flow Execution

### State Machine

Player uses a finite state machine to drive flow execution:

1. **BEGIN** - Initial state
2. **VIEW** - Display content to user
3. **ACTION** - Execute actions (user input, external calls)
4. **EXTERNAL** - External system integration
5. **END** - Terminal state with outcome

### Flow Controller

The FlowController manages:

- **State Transitions** - Moving between flow states
- **Navigation Logic** - Determining next state based on conditions
- **Flow Lifecycle** - Starting, pausing, and completing flows

## Asset System

### Asset Types

Assets are the building blocks of Player experiences:

- **Views** - Display content (text, forms, lists)
- **Actions** - User interactions (buttons, inputs)
- **Expressions** - Dynamic content and logic
- **Validators** - Data validation rules

### Asset Registry

The asset registry maps asset types to their implementations:

```typescript
class AssetRegistry {
  register(type: string, component: Component) {
    // Register asset type with component
  }

  get(type: string): Component {
    // Retrieve component for asset type
  }
}
```

## Data Binding

### Binding System

Player uses a powerful binding system for dynamic content:

- **Expression Evaluation** - `{{user.name}}` syntax
- **Data References** - `{{data.field}}` for accessing flow data
- **Computed Values** - Dynamic calculations and transformations

### Data Controller

The DataController manages:

- **Data Updates** - Handling changes to flow data
- **Binding Resolution** - Resolving expressions and references
- **State Persistence** - Maintaining data across state transitions

## Extensibility Patterns

### Custom Assets

Create custom asset types by:

1. **Defining the Asset** - Type, properties, and behavior
2. **Implementing the Component** - Platform-specific rendering
3. **Registering with Player** - Adding to the asset registry

### Custom Plugins

Extend Player functionality by:

1. **Identifying Extension Points** - Which hooks to tap into
2. **Implementing Plugin Logic** - What functionality to add
3. **Registering with Player** - Adding the plugin to Player

### Custom Expressions

Add new expression types by:

1. **Defining Expression Syntax** - How to parse the expression
2. **Implementing Evaluation** - What the expression does
3. **Registering with ExpressionController** - Making it available

## Best Practices

### Plugin Design

- **Single Responsibility** - Each plugin should have one clear purpose
- **Hook Selection** - Choose the most specific hook for your needs
- **Error Handling** - Gracefully handle errors and edge cases
- **Performance** - Avoid expensive operations in frequently called hooks

### Asset Development

- **Platform Agnostic** - Keep business logic separate from UI
- **Reusable Components** - Design assets to work across different contexts
- **Type Safety** - Use TypeScript interfaces for asset properties
- **Documentation** - Clearly document asset behavior and usage

### Flow Design

- **State Clarity** - Make state transitions clear and predictable
- **Error States** - Handle error conditions gracefully
- **User Experience** - Design flows that guide users naturally
- **Testing** - Test flows with various data and conditions

## Conclusion

Player's architecture is designed around extensibility and platform independence. The plugin system provides hooks at every level, allowing you to customize and extend Player to meet your specific needs. Whether you're building custom assets, adding new functionality, or integrating with external systems, Player's architecture provides the foundation you need.
